<!DOCTYPE html>
<html>
    <head>
        <style>
            body { padding: 0; margin: 0; }
            #gameCanvas { display: block; }
        </style>
    </head>
    <body>
        <script>
            "use strict";
            let textDecoder = new TextDecoder("utf8");
            let glObjects = [null];
            let wasmMemoryU8;
            let wasmMemoryS32;
            let wasmMemoryU32;
            let wasmExports;
            let canvas;

            function glPush(object) {
                return glObjects.push(object) - 1;
            }
            function glPop(index) {
                let object = glObjects[index];
                glObjects[index] = null;
                return object;
            }

            let mainLoopFrameCounter;
            let mainLoopPrevTime;
            function mainLoop() {
                let status = wasmExports.game_draw();
                if (status < 0) throw "Failed to draw game (" + status + ")";

                ++mainLoopFrameCounter;
                let currentTime = performance.now();
                if (currentTime - mainLoopPrevTime >= 1000) {
                    console.log("FPS: " + mainLoopFrameCounter);
                    mainLoopFrameCounter = 0;
                    mainLoopPrevTime = currentTime;
                }
                window.requestAnimationFrame(mainLoop);
            }
            function main() {
                // Initialise webGL.
                canvas = document.getElementById("gameCanvas");
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                let gl = canvas.getContext("webgl2", { antialias: false });
                if (gl === null) throw "Failed to initialise webgl2 context.";

                let importObject = {
                    env: {
                        gl_getError: () => gl.getError(),
                        gl_createShader: type => glPush(gl.createShader(type)),
                        gl_shaderSource: (shader, count, string, length) => {
                            while (count) {
                                --count;
                                let start = wasmMemoryS32[(string >> 2) + count];
                                let end;
                                if (!length) {
                                    for (end = start; wasmMemoryU8[end]; ++end);
                                } else {
                                    end = start + wasmMemoryS32[length >> 2];
                                }
                                gl.shaderSource(glObjects[shader], textDecoder.decode(wasmMemoryU8.subarray(start, end)));
                            }
                        },
                        gl_compileShader: shader => gl.compileShader(glObjects[shader]),
                        gl_createProgram: () => glPush(gl.createProgram()),
                        gl_attachShader: (program, shader) => gl.attachShader(glObjects[program], glObjects[shader]),
                        gl_linkProgram: program => gl.linkProgram(glObjects[program]),
                        gl_deleteShader: shader => gl.deleteShader(glPop(shader)),
                        gl_genBuffers: (n, buffers) => {
                            while (n) {
                                --n;
                                wasmMemoryU32[(buffers >> 2) + n] = glPush(gl.createBuffer());
                            }
                        },
                        gl_genVertexArrays: (n, arrays) => {
                            while (n) {
                                --n;
                                wasmMemoryU32[(arrays >> 2) + n] = glPush(gl.createVertexArray());
                            }
                        },
                        gl_bindBuffer: (target, buffer) => gl.bindBuffer(target, glObjects[buffer]),
                        gl_bufferData: (target, size, data, usage) => gl.bufferData(target, wasmMemoryU8.subarray(data, data + size), usage),
                        gl_bindVertexArray: array => gl.bindVertexArray(glObjects[array]),
                        gl_vertexAttribPointer: (index, size, type, normalized, stride, pointer) => gl.vertexAttribPointer(index, size, type, normalized, stride, pointer),
                        gl_enableVertexAttribArray: index => gl.enableVertexAttribArray(index),
                        gl_useProgram: program => gl.useProgram(glObjects[program]),
                        gl_deleteBuffers: (n, buffers) => {
                            while (n) {
                                --n;
                                gl.deleteBuffer(glPop(wasmMemoryU32[(buffers >> 2) + n]));
                            }
                        },
                        gl_deleteVertexArrays: (n, arrays) => {
                            while (n) {
                                --n;
                                gl.deleteVertexArray(glPop(wasmMemoryU32[(arrays >> 2) + n]));
                            }
                        },
                        gl_deleteProgram: program => gl.deleteProgram(glPop(program)),
                        gl_clearColor: (red, green, blue, alpha) => gl.clearColor(red, green, blue, alpha),
                        gl_clear: mask => gl.clear(mask),
                        gl_drawArrays: (mode, first, count) => gl.drawArrays(mode, first, count),
                        gl_viewport: (x, y, width, height) => gl.viewport(x, y, width, height)
                    }
                };
                WebAssembly.instantiateStreaming(fetch("release.wasm"), importObject).then(
                    object => {
                        wasmExports = object.instance.exports;
                        wasmMemoryU8 = new Uint8Array(wasmExports.memory.buffer);
                        wasmMemoryS32 = new Int32Array(wasmExports.memory.buffer);
                        wasmMemoryU32 = new Uint32Array(wasmExports.memory.buffer);

                        let status = wasmExports.game_init();
                        if (status < 0) throw "Failed to initialise game (" + status + ")";

                        window.addEventListener("resize", () => {
                            let width = window.innerWidth;
                            let height = window.innerHeight;
                            canvas.width = width;
                            canvas.height = height;
                            wasmExports.game_resize(width, height);
                        });

                        mainLoopFrameCounter = 0;
                        mainLoopPrevTime = performance.now();
                        mainLoop();
                    }
                );
            }
            window.onload = main;
        </script>
        <canvas id="gameCanvas"></canvas>
    </body>
</html>